#include<iostream>
#include<vector>
#include<algorithm>
#include<functional>
/*
As we've seen, to make a call through a pointer to
member function, we must use .* or ->* operators to a specific
object. As a result, unlike ordinary function pointers, a pointer
to member is not a callable object; these pointers do not support
the function-call operator.
Because a pointer to member is not a callable object,we cnanot directly
pass a pointer to a member function to an algorithm. As an example, if we
want to find the first empty string in a vector of strings, the obvious call
can't work:
*/
bool is_empty(const std::string&str){
return str.empty();
}
int main(){
    std::vector<std::string>svec={"nima","sile","","sjjhd"};
    auto fp=&std::string::empty;
    //error: must use .* or ->* to call a pointer to member
  // &&&&&&&&&&&&&&&&&&&&find_if(svec.begin(),svec.end(),fp);&&&&&&&&&&&&&&&&&&&//

    //The find_if algorithm expects a callable object, but we've supplied
    //fp, which is a pointer to a member function. This call won't compile, because the code
    //inside find_if executes a statement something like:
    //check whether the given predicate applied to the current element yields true
    //&&&&&&&&&&&&&&&&&&7if(fp(*it))&&&&&&&&&&&&&&&&7//

    //error: must use ->* to call through a pointer to member
    //which attempts to call the object it was passed.


    /*using function to generate a callable*/
    std::function<bool(const std::string&)>fcn=&std::string::empty;
    std::find_if(svec.begin(),svec.end(),fcn);
    //Here we tell function that empty is a function that can be called 
    //with a string and returns a bool. Ordinarily, the object on which a member
    //function executes is passed to the implicit this parameter. When we want to
    //use function to generate a callable for a member function, we have to "translate"
    //the code to make that implicit parameter explicit.
     
     //assuming it is the iterator inside find_if, so *it is an object in the given range:
     //&&&&&&&&&&if(((*it).*p)())&&&&&&&&&&&//
      std::vector<std::string>::const_iterator it1= 
       std::find_if(svec.cbegin(),svec.cend(),mem_fn(&std::string::empty));
       //Here we used mem_fn(&std::string::empty) to generate a callable object that takes a string
       //arguments and return a bool.
       //The callable generated by mem_fn can be called on either an object or a pointer
       auto f=mem_fn(&std::string::empty);
      std::cout<<(svec.cbegin()-it1)<<std::endl;//-2
     using namespace std::placeholders;
     auto it2=find_if(svec.cbegin(),svec.cend(),
     bind(&std::string::empty,_1));
     std::string str=const_cast<std::string&>(*(it2+1));
     std::cout<<str<<std::endl;//sjjhd 
     
}
